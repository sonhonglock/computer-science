#include <stdio.h>
#include <stdbool.h>    // bool, true, false 사용하려면

#define MAX_V 100       // 정점 최대 개수 (필요에 따라 조정)

// 인접 리스트로 그래프 표현 (각 정점의 인접 정점들을 연결 리스트로)
typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

Node* adjList[MAX_V];   // 인접 리스트 배열

// 함수 선언
void recursiveDFS(bool isMarked[], int start);
void DFS(int start, int V);   // V는 정점 개수

int main(void) {
    // 예시 그래프 (0번부터 시작한다고 가정)
    // 여기서는 직접 연결 리스트를 만들어줌
    int V = 7;  // 정점 0~6

    // 인접 리스트 초기화
    for (int i = 0; i < V; i++) {
        adjList[i] = NULL;
    }

    // 예시 간선 추가 (무방향 그래프라고 가정)
    // 0-1, 0-2, 1-3, 1-4, 2-5, 2-6
    int edges[][2] = {{0,1},{0,2},{1,3},{1,4},{2,5},{2,6}};
    int edge_count = 6;

    for (int i = 0; i < edge_count; i++) {
        int u = edges[i][0];
        int v = edges[i][1];

        // u → v
        Node* newNode = (Node*)malloc(sizeof(Node));
        newNode->vertex = v;
        newNode->next = adjList[u];
        adjList[u] = newNode;

        // v → u (무방향)
        newNode = (Node*)malloc(sizeof(Node));
        newNode->vertex = u;
        newNode->next = adjList[v];
        adjList[v] = newNode;
    }

    printf("DFS 시작 (0번 정점부터): ");
    DFS(0, V);   // 0번 정점에서 시작

    return 0;
}

// DFS 메인 함수
void DFS(int start, int V) {
    bool isMarked[MAX_V] = {false};   // C99 이상에서 가능
    // 또는 아래처럼 memset으로 초기화
    // bool isMarked[MAX_V];
    // memset(isMarked, 0, sizeof(isMarked));

    recursiveDFS(isMarked, start);
    printf("\n");
}

// 재귀 DFS
void recursiveDFS(bool isMarked[], int start) {
    if (isMarked[start] == true) {
        return;
    }

    // 방문
    printf("%d ", start);
    isMarked[start] = true;

    // 인접 정점들 방문
    Node* ptr = adjList[start];
    while (ptr != NULL) {
        int next = ptr->vertex;
        recursiveDFS(isMarked, next);
        ptr = ptr->next;
    }
}