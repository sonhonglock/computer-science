#include <stdio.h>
#include <stdlib.h>
#define max_size 5
#define MAX_SIZE 100000

#-----------------------------------------------#
/* 작동 자체는 정상적으로 되는 코드인데,시간이 너무 초과돼서
문제가 요구하는 것을 잘 캐치하지 못했던 것 같다. 
문제에서 요구하는 건,모든 배열을 다 순회하는게 아니였다.
문제에 실질적으로 영향을 미치는 건 오른쪽에서부터 가장 먼저
발견되는 '큐'라는 것을 깨닫지 못해서 시간이 오래걸렸다.*/
#-----------------------------------------------#


//원형 덱 구현//
typedef struct deque
{
    int front;
    int rear;
    int arr[max_size];
    int count;
    int isstackque;
}deque;

void dequeinit(deque* d)
{
    d->front = 0;
    d->rear = 0;
    d->count = 0;
    d->isstackque = -1;
}

int isempty(deque* d)
{
    return (d->count ==0);
}

int isfull(deque* d)
{
    return (d->count == max_size);
}

void insertfront(deque* d,int data)
{
    if (isfull(d)) return;
    
    d->front = (d->front-1+max_size)%max_size;
    d->arr[d->front] = data;
    d->count++;
}

void insertrear(deque* d,int data)
{
    if (isfull(d)) return;
    
    d->arr[d->rear] = data;
    d->rear = (d->rear+1)%max_size;
    d->count++;
}

int popfront(deque* d)
{
    if (isempty(d)) return -1;
    
    int popdata = d->arr[d->front];
    d->front = (d->front+1)%max_size;
    d->count--;
    return popdata;
}

int poprear(deque* d)
{
    if (isempty(d)) return -1;
    
    d->rear = (d->rear-1+max_size)%max_size;
    int popdata = d->arr[d->rear];
    d->count--;
    return popdata;
}

typedef struct queuestack
{
    deque arr[MAX_SIZE];
    int count;
}queuestack;

void queuestackinit(queuestack* qs,int count)
{
    qs->count = count;
    for (int i=0;i<qs->count;i++)
    {
        dequeinit(&(qs->arr[i]));
    }
}

int main() {
   int N;
   scanf("%d",&N);
   queuestack qs;
   queuestackinit(&qs,N);
   
   for (int i=0;i<N;i++)
   {
       int a;
       scanf("%d",&a);
       (qs.arr[i]).isstackque = a;
   }
   
   for (int i=0;i<N;i++)
   {
       int a;
       scanf("%d", &a);
       insertrear(&(qs.arr[i]),a);
   }
   
   int M;
   scanf("%d",&M);

   for (int i=1;i<M;i++)
   {
       int a;
       scanf("%d",&a);
       int temp = a;
       int contiunous = 1;
       insertrear(&(qs.arr[0]),temp);
       
       for (int j=0;j<N-1;j++)
       {
           if ((qs.arr[j]).isstackque == 0) contiunous = 0;
           if (contiunous) continue;
          
           if ((qs.arr[j]).isstackque == 0)
           {
               insertrear(&(qs.arr[j+1]),popfront(&(qs.arr[j])));
           }
           else if ((qs.arr[j]).isstackque == 1)
           {
               insertrear(&(qs.arr[j+1]),poprear(&(qs.arr[j])));
           }
       }
       if ((qs.arr[N-1]).isstackque == 0)
       {
           printf("%d ",popfront(&(qs.arr[N-1])));
       }
       else if ((qs.arr[N-1]).isstackque == 1)
       {
           if (contiunous)
           {
               printf("%d ",a);
           }
           else
           {
               printf("%d ",poprear(&(qs.arr[N-1])));
           }
       }
   }
   
   int a;
   scanf("%d",&a);
   insertrear(&((qs.arr[0])),a);
   
   int contiunous = 1;
   for (int j=0;j<N-1;j++)
   {
       if ((qs.arr[j]).isstackque == 0) contiunous = 0;
       if (contiunous) continue;
       
       if ((qs.arr[j]).isstackque == 0)
       {
           insertrear(&(qs.arr[j+1]),popfront(&(qs.arr[j])));
       }
       else if ((qs.arr[j]).isstackque == 1)
       {
           insertrear(&(qs.arr[j+1]),poprear(&(qs.arr[j])));
       }
   }
   
   if (contiunous)
   {
       printf("%d",a);
       return 0;
   }
   
   if ((qs.arr[N-1]).isstackque == 0)
       {
           printf("%d",popfront(&(qs.arr[N-1])));
       }
       else if ((qs.arr[N-1]).isstackque == 1)
       {
           printf("%d",poprear(&(qs.arr[N-1])));
       }
    return 0;
}
