// 원형덱에서, front와 rear 인덱스가 한단계식 차이난다는걸 자꾸 까먹어서 며칠동안 해맸다.//
// 예를 들어, insertrear는 삽입 후, 인덱스 증가가 이루어지는데, insertfront는 인덱스 감소 후 삽입이 이뤄진다.//
// 이런 성질을 잘 이해하지 못해서 대략적인 구조는 다 짰는데 답이 계속 이상하게 나와서 해맸다.//
// 백준 2346번 //

#include <stdio.h>
#include <stdlib.h>
#define max_size 1000

typedef struct node
{
    int idx;
    int num;
}node;

typedef struct deque
{
    int front;
    int rear;
    int count;
    node arr[max_size];
}deque;

void dequeinit(deque* d)
{
    d->front = 0;
    d->rear = 0;
    d->count = 0;
}

int isempty(deque* d)
{
    if (d->count ==0)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int isfull(deque* d)
{
    return (d->count == max_size);
}

void insertfront(deque* d,node data)
{
    if (isfull(d)) return;
    
    d->front = (d->front-1+max_size)%max_size;
    d->arr[d->front] = data;
    d->count++;
}

void insertrear(deque* d,node data)
{
    if (isfull(d)) return;
    
    d->arr[d->rear] = data;
    d->rear = (d->rear+1)%max_size;
    d->count++;
}

node popfront(deque* d)
{
    if (isempty(d))
    {
        node empty = {-1,0};
        return empty;
    }
    
    node popdata = d->arr[d->front];
    d->front = (d->front+1)%max_size;
    d->count--;
    return popdata;
}

node poprear(deque* d)
{
    if (isempty(d))
    {
        node empty = {-1,0};
        return empty;
    }
    
    d->rear = (d->rear-1+max_size)%max_size;
    node popdata = d->arr[d->rear];
    d->count--;
    return popdata;
}

node peekfront(deque* d)
{
    if (isempty(d))
    {
        node empty = {-1,0};
        return empty;
    }
    
    return d->arr[d->front];
}

node peekrear(deque* d)
{
    if (isempty(d))
    {
        node empty = {-1,0};
        return empty;
    }
    
    return d->arr[(d->rear-1+max_size)%max_size];
}

void printdeque(deque* d)
{
    if (isempty(d))
    {
        printf("데이터 없음 !!");
        return;
    }
    int idx = d->front;
    for (int i=0;i<d->count;i++)
    {
        printf("%d ",d->arr[idx].num);
        idx = (idx+1)%max_size;
    }
}

int main() {
    int N;
    scanf("%d",&N);
    deque d;
    dequeinit(&d);
    for (int i=0;i<N;i++)
    {
        int a;
        scanf("%d",&a);
        node data;
        data.num = a;
        data.idx = i+1;
        insertrear(&d,data);
    }
    printf("%d ",d.arr[d.front].idx);
    node popdata = popfront(&d);
 
    while (d.count > 1)
    {
        if (popdata.num > 0)
        {
            for (int i=1;i<popdata.num;i++)
            {
                insertrear(&d,popfront(&d));
            }
            printf("%d ",(d.arr[d.front].idx));
            popdata = popfront(&d);
        }
        else
        {
            for (int i=1;i<abs(popdata.num);i++)
            {
                insertfront(&d,poprear(&d));
            }
            printf("%d ",(d.arr[(d.rear-1+max_size)%max_size].idx));
            popdata = poprear(&d);
        }
    }
    printf("%d",d.arr[d.front].idx);
}
