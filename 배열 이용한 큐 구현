#include <stdio.h>
#include <stdlib.h>

#pragma warning (disable : 4996)

#define MAX_SIZE 5

typedef struct queue
{
	int arr[MAX_SIZE];	//큐로 사용할 배열
	int rear;			//삽입할 위치(배열의 인덱스)
	int front;			//삭제할 위치(배열의 인덱스)
	int count;			//저장된 요소의 개수
}queue;

void initQueue(queue* ptr);
void enqueue(queue* ptr, int data);
int dequeue(queue* ptr);
int peek(const queue* const ptr);
int isEmpty(const queue* const ptr);
void printQueue(const queue* const ptr);

int main()
{
	int choice, data;
	queue que; //큐 구조체 생성
	initQueue(&que);

	while (1)
	{
		system("cls");
		printf("\n\n\t\t****  배열을 이용한 원형 큐 ***\n\n");
		printf("1. enqueue    2. dequeue    3. peek    4. print    5. clear   0. terminate\n");
		printf("choice : [ ]\b\b");
		scanf("%d", &choice);
		while (getchar() != '\n');

		switch (choice)
		{
		case 1:
			printf("\n\nEnter an integer: ");
			scanf("%d", &data);

			enqueue(&que, data);
			break;
		case 2:
			data = dequeue(&que);

			if (data == -99999)
				printf("\n\n\t\tQueue underflow\n");
			else
				printf("\n\n\t\tDequeue value? %d\n", data);
			break;
		case 3:
			data = peek(&que);

			if (data == -99999)
				printf("\n\n\t\tQueue underflow\n");
			else
				printf("\n\n\t\tPeek value? %d\n", data);
			break;
		case 4:
			printQueue(&que);
			break;
		case 5:
			//논리적인 삭제
			initQueue(&que);
			break;
		case 0:
			exit(0);
		}
		printf("\n\n\t\t");
		system("pause");
	}
	return 0;
}

void initQueue(queue* ptr)
{
	ptr->front = ptr->rear = ptr->count = 0;
}

void enqueue(queue* ptr, int data)
{
	if (ptr->count >= MAX_SIZE)
	{
		printf("\n\n\t\tQueue Overflow\n");
		return;
	}
	ptr->arr[(ptr->rear)++] = data;
	ptr->rear %= MAX_SIZE;//원형큐를 만들기 위한 작업
	//(ptr->rear)++; //저장 위치 변경
	(ptr->count)++; //저장된 원소의 개수를 1증가

	//원형큐를 만들기 위한 작업
	//if (ptr->rear == MAX_SIZE)
	//	ptr->rear = 0;
}

int dequeue(queue* ptr)
{
	//if (ptr->count <= 0)
	if (isEmpty(ptr))
		return -99999; //underflow

	int delValue = ptr->arr[(ptr->front)++]; //삭제될 값 저장
	//논리적인 삭제
	//(ptr->front)++;//삭제 위치 변경
	ptr->front %= MAX_SIZE; //원형큐를 만들기 위한 작업
	(ptr->count)--;//저장된 원소의 개수를 1감소

	//원형큐를 만들기 위한 작업
	//if (ptr->front == MAX_SIZE)
	//	ptr->front = 0;
	return delValue;
}

int isEmpty(const queue* const ptr)
{
	if (ptr->count <= 0)
		return 1;
	else
		return 0;
}

void printQueue(const queue* const ptr)
{
	//First In First Out: 선입선출
	printf("\n\n\t\tQueue Display(FIFO): ");
	if (isEmpty(ptr))
	{
		printf("Stack is empty\n");
		return;
	}

	for (int i = ptr->front; i < ptr->front + ptr->count; i++)
	{
		//arr[3 % 5], arr[4 % 5], arr[5 % 5], arr[6 % 5]
		printf("%d ", ptr->arr[i % MAX_SIZE]);
	}
}

int peek(const queue* const ptr)
{
	if (isEmpty(ptr))
		return -99999;
	
	return ptr->arr[ptr->front]; //맨 앞에 저장된 값
}
