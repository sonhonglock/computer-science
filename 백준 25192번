/* enter 가 들어가는 유형은 처음 만나봐서 고전했다.
enter 가 들어가는 유형은 version 변수를 도입하는 것이 문제 해결의 핵심이라는 것을 알게됐다.*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define table_size 200003

typedef struct node
{
    char arr[21];
    struct node* next;
    int version;
}node;

typedef struct hashtable
{
    node** head;
    int size;
    int version;
}hashtable;

void hashinit(hashtable* h,int version)
{
    h->size = table_size;
    h->head = (node**)calloc(table_size,sizeof(node*));
    h->version = version;
}

unsigned long long hash(char arr[21])
{
    unsigned long long result = 0;
    char* temp = arr;
    while (*(temp) != '\0')
    {
        result = (result*131+(unsigned char)*temp)%table_size;
        temp++;
    }
    return result;
}

void hashinsert(hashtable* h,char arr[21])
{
    unsigned long long idx = hash(arr);
    node* newnode = (node*)malloc(sizeof(node));
    strcpy(newnode->arr,arr);
    newnode->version = h->version;
    newnode->next = NULL;
    
    if (h->head[idx] == NULL)
    {
        h->head[idx] = newnode;
        return;
    }
    
    newnode->next = h->head[idx];
    h->head[idx] = newnode;
}

int findhash(hashtable* h,char arr[21])
{
    unsigned long long idx = hash(arr);
    node* curnode = h->head[idx];
    
    while (curnode)
    {
        if (strcmp(curnode->arr,arr)==0)
        {
            if (curnode->version == h->version) return 1;
            return 0;
        }
        curnode = curnode->next;
    }
    return 0;
}

void cleanhash(hashtable* h)
{
    memset(h->head, 0, sizeof(node*) * h->size);
}

int main() {
    int version = 1;
    int N;
    scanf("%d",&N);
    hashtable h;
    hashinit(&h,version);
    int count =0;
    char enter[21] = "ENTER";
    
    for (int i=0;i<N;i++)
    {
        char arr[21];
        scanf("%s",arr);
        if (strcmp(arr,"ENTER")==0)
        {
            h.version++;
            continue;
        }
        
        if (!findhash(&h,arr))
        {
            count++;
            hashinsert(&h,arr);
        }
    }
 
    printf("%d",count);
}
